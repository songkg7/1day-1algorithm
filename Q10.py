# 신입사원
# 탐욕법
# 백준 1946번

# 방법 1.
# 둘 중 하나라도 다른 지원자의 성적보다 높다면 합격
# 서류심사 성적을 내림차순으로 정렬한 뒤에 면접심사 성적을 다음 인덱스 지원자와 비교
# 만약 면접심사 성적이 다음 지원자보다 낮다면? => 두 성적이 자신보다 높으므로 불합격
# 높다면? => 무조건 합격 => pass(합격자 배열)에 추가
# pass의 길이 : 선발할 수 있는 신입사원의 최대 인원수.

# 방법 2.
# 서류 성적 순으로 오름차순 정렬
# 서류 성적 1위의 면접 성적보다 점수가 높은 사람만 합격할 수 있음
# => 둘 중 하나라도 더 잘해야하므로
# 면접 성적이 서류 성적 1위보다 높더라도 서류 성적이 최하위이면 제외된다
# 둘 중 하나가 꼴등이라면 남은 성적 하나는 무조건 1위여야함.

# 방법 3.
# emp1에 모든 지원자의 순위를 저장
# 서류 순위 순으로 emp1 오름차순 정렬
# 필터를 사용하여 면접 순위가 서류 순위 1위보다 높은 사람만 필터링 후 emp2 저장
# emp2을 면접 순위로 오름차순 정렬
# emp2의 면접 1위보다 서류 순위가 높은 사람만 필터링하여 pass에 저장
# pass의 길이 : 선발할 수 있는 신입사원의 최대 인원 수.

from operator import itemgetter # 다차원배열의 정렬을 위해 사용

T = int(input()) # 테스트의 갯수

pass_cnt = []
for _ in range(T):
    emp1 = [] # 전체 지원자의 순위
    emp2 = [] # 1차 합격자의 순위
    cnt = 1 # 최종합격자의 인원수, 한명도 통과하지 못하는 경우는 없다
    N = int(input()) # 지원자의 숫자
    
    # [서류심사 순위, 면접 순위]
    for _ in range(N):
        emp1.append(list(map(int, input().split())))

    # 서류 순위로 정렬
    emp1.sort(key=itemgetter(0))
    # print(emp1)

    for i in emp1:
       if i[1] <= emp1[0][1]: # 자기 자신은 통과해야한다
           emp2.append(i) # 1차 합격자

    # 면접 순위로 정렬
    emp2.sort(key=itemgetter(1))
    # print(emp2)

    for i in emp2:
        if i[0] < emp2[0][0]:
            cnt += 1
    
    pass_cnt.append(cnt) # 최종 합격자의 인원수를 저장
    
for i in pass_cnt:
    print(i)
